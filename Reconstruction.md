## 摘要

这个方法是在自动和交互之中平衡的方法。

有两个主要的重建交互：

- 在不同碎片中，选择出需要匹配表面的区域。
- 初始化每一个和整个碎片的排列优化。

每一个排列优化被用户初始化，都有输入：

- 已经被选好的匹配
- 碎片现在的位置





## 简介

为防止PTOA( 伤后骨科综合症)，有必要按照骨科复位进行手术。

一个重建交互系统：

![1](https://github.com/freyakniglty/algorithm/blob/master/images/r1.jpg)



## 存在的问题

骨头重建有两个主要的限制：

1.骨头碎片的表面匹配仅仅由来自一个或者几个表面的点组成。

2.一个大骨骼可以与很多不同的骨头碎片匹配。所以它并不是一对一的关系。

所以并不能借用现有的石头陶瓷等复原，材料特性不同，而且是一对一的。



## 方法步骤

分两步：

1.建立一个用户的操作界面。用户可以在这个界面上操作碎片模型，可以粗略地匹配碎片。

2.排列算法可以选择用户放置的碎片，并且能精确匹配，然后重建模型。最小化这个排列匹配的误差。



#### 交互界面

1.每一个骨头部分都可以自由旋转移动。这样可以防止部分离要匹配的位置旋得太过。

2.可以选择每一个部分，粗略地匹配。告诉那个区域是对应的。这样可以防止部分离所需要匹配的地方过远。

可以创建一个按钮，告诉用户下一个匹配的地方在哪里，然后让他粗略选择。不需要让用户拼合，可以让用户选择bounding box...也就是包含部分的一个立方体或者是鼠标点击一下位置。

这样可以防止搜索过程太长过于复杂。

这样就建立了一个匹配表。

3.初始化匹配排列。在任何时间点，用户可以选择自动重建。



这样的人机交互系统，有几个地方会影响到得到一个满意的重建模型需要的时间：

1.最后结果依赖于人工把各个部分放在哪，以及选择的复杂度精确度。

2.选择较小的部分会需要更精细的测量，否则会导致医学上不好的结果，如果那一块特别需要的话。



#### 排列优化

有两个问题：

- 对一个给定的部分，用户可能选择几个位置和它匹配
- 一个部分，可以匹配多个部分。

提出两个前处理步骤。

- 首先对于相同的一个部分，将所有要和它匹配的位置放到一个组里。
- 其次创建一个图G（M,F）,其中F是结点，M是边。

骨骼重建用这个图G来决定出现的顺序。随着每一次拼合，所有的部分位置要根据已拼合的部分更新。



#### 算法步骤

1.计算G(M,F) 根据用户预先的匹配。

注意，两个结点之间可以有多条边。当用户选择了匹配的多个位置。

2.建立一个动态的和一个静止的集合。一开始，所有的部分都放入静止的那个集合。

3.在静止集里选择一个边最多的部分。

4.与动态集混合。

5.保持住动态集中已经修复的部分，将选择的部分与动态集中的部分进行排列。

6.对所有在动态集中的部分进行适应新部分的排列。

7.如果静止集不为空，则从第三步开始。如果空了，则退出排列算法。



一般而言选择最多匹配的部分。另一个情况下，如果一个部分还存在大骨头上，没有碎片化，就可以选择这个部分。



#### 对于部分之间的算法

5.6.步骤需要另一个排序算法，它调整部分的位置去最小化匹配错误，对于所有在动态集的表面。

选择ICP算法。（iterative closest point）

困难在于：

- 识别两个表面每一个的重合区域。
- 根据以上找到相对应的点。

经典的方法，如果用欧拉变换做的话，比如平移和旋转。则最小化相应点之间距离的开方所得的误差。

让X,Y分别代表两个表面对应的点集。现在要需要一个配对集C。里面的元素为（i,j）如果xi与yj是对应的重合区域的点的话。这个排列问题就转变为找到一个变换T = {R,t} 的最小值：

$\hat{T} = min_{R,t} \sum_{(i,j)\in C}f(x_i,y_j,R,t)$

这里的f是一个测度函数。记最初变换为T0，k次迭代之后，变换为Tk



然后我们定义一个一对一的映射，从一个较小的点集到另一个点集：

$\hat{j} = min_j||x_i-R_k(y_j-t_k)||^2$



ICP算法就是计算$T_{k+1}$ 

两个核心对此算法的改进在此有：

- 定义一个误差测度。即为点到平面，而不是点到点的距离。匹配整个表面，而不是特定的取样。可以增对变化的强鲁棒性。
- Sub-sampling（二次取样）。这个问题经常会出现一些冗余信息，对于最后的结果没有用处。通过二次取样来匹配一个更小的集合，减少计算量。

由以下步骤得到匹配表面的点取样：

1.计算C的特征向量和特征值：

$C = FF^T = \begin{bmatrix} p_1 \times n_1 &...& p_k \times n_k \\n_1&...&n_k \end{bmatrix} \begin{bmatrix}(p_1 \times n_1)^T&n_1^T\\.&.\\.&.\\.&.\\(p_k \times n_k)^T& n_k^T\end{bmatrix}$

特征值大的表示未知的变化受限于数据较高，特征值小则反之。



2.对于每一点，pi, 和相应的法向量ni。计算六维向量 $v_i = \begin{bmatrix}(p_i \times n_i)& n_i\end{bmatrix}$

这个vi映射在C的六个特征向量上，并且被记录在一个和六个特征向量相关的排序表中。



3.几何稳定取样几何由从6个列表中选择最大值而得到。直到映射值能提供一个稳定的解。



这个方法用 $p_i^\prime = p_i - \bar{p}$ 来代替位置 $p_i$ 获得更快的速度。 















